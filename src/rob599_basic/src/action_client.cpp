// Simple action client in C++.
//
// action_client.cpp
//
// Bill Smart
//
// This is an example of a SimpleActionClient for the fibonacci action server, using callbacks.


// Include the basic ROS stuff.
#include <ros/ros.h>

// Include the actionlib client code.
#include <actionlib/client/simple_action_client.h>

// Include the action message definition, auto-generated by catkin.
#include <rob599_basic/FibonacciAction.h>

// We're going to be doing some basic operations on the vector that gets returned by the action,
// so we need to include the STL vector header.
#include <vector>

// We're going to grab stuff from the command-line, so we're going to need to parse numbers.
#include <cstdlib>


// A callback that gets called when the action is done.  Two arguments are passed in.  The final state of the action server, 
// and the result data.  The callback should have a void return type.
void done_callback(const actionlib::SimpleClientGoalState &state, const rob599_basic::FibonacciResultConstPtr &result) {
	// If the action succeeded, the print out the results.
	if (state == actionlib::SimpleClientGoalState::SUCCEEDED) {
		// Print out each of the elements of the vector of results.  Note that this is considerably more involved than
		// printing out a Python list.
		ROS_INFO("Succeeded with result:");
		for(std::vector<long int>::const_iterator it = result->sequence.begin(); it != result->sequence.end(); ++it)
			ROS_INFO("  %li", *it);
	} else {
		// If we didn't succeed, then mark this up as a failure.
		ROS_INFO("Action failed!");
	}
}


// The callback that is called when the action becomes active.  Should have a void return type and no parameters.
void active_callback() {
	ROS_INFO("Action is active");
}


// The callback that gets called whenever there's feedback.  Should have a void return type, and takes one argument, a
// const pointer reference to the feeedback type.
void feedback_callback(const rob599_basic::FibonacciFeedbackConstPtr &feedback) {
	ROS_INFO("Feedback: %li", feedback->progress);
}


int main(int argc, char **argv) {
	int number = 10;

	if (argc == 2)
		number = atoi(argv[1]);

	// Initialize the node and set a node handle.
	ros::init(argc, argv, "action_client");
	ros::NodeHandle node;

	// Create a SimpleActionClient, passing in the node handle, an action name, and a boolean.  If the boolean is true,
	// the SimpleActionClient handles all of the threading.  If it's set to false, then you're responsible for thread
	// management.  Set it to true unless you have a compelling reason not to.
	actionlib::SimpleActionClient<rob599_basic::FibonacciAction> client(node, "fibonacci", true);

	// Wait until we have a connection to the server.
	client.waitForServer();

	// Construct a goal instance and fill in the data fields.
	rob599_basic::FibonacciGoal goal;
	goal.number = number;

	// Send the goal, registering the appropriate callbacks.
	client.sendGoal(goal, &done_callback, &active_callback, &feedback_callback);

	// Wait until the action is done.
	client.waitForResult();

	return 0;
}