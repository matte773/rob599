// Basic action server functionality for C++.
//
// action_server.cpp
//
// Bill Smart
//
// This example show the SimpleActionServer functionality, and uses it to serve up sequences of Fibonacci numbers.


// Include the basic ROS stuff.
#include <ros/ros.h>

// We're going to need actionlib's SimpleActionServer.
#include <actionlib/server/simple_action_server.h>

// Include the action definion auto-generated by catkin.
#include <rob599_basic/FibonacciAction.h>


// This ia a naive implementation of a Fibonacci number calculator.  This is not something you'd really want to serve up with an action
// server, but it's a good placeholder.  It takes a variable amount of time, can be quite long, and allows you to give intermittent feedback.
int fibonacci(const int n) {
	if (n < 2)
		return n;
	else
		return fibonacci(n - 1) + fibonacci(n - 2);
}


// This is the callback that handles the action request.  It should return void, and takes two arguments.  A const pointer reference to the goal
// and a pointer to the action server.
void action_callback(const rob599_basic::FibonacciGoalConstPtr &goal, actionlib::SimpleActionServer<rob599_basic::FibonacciAction> *server) {
	// Make an instance of the result data type.
	rob599_basic::FibonacciResult result;

	// We're going to count up from zero, calculating each Fibonacci number in turn.  This is a dumb way to calculate these numbers, but we're
	// doing it this way to make a point about action servers.
	for(int i = 0; i <= goal->number; ++i) {
		// Check to see if we've been preempted.  If we have, or ROS is otherwise not OK (perhaps the node is shutting down), then set the
		// server status to preempted, and return.
		if (server->isPreemptRequested() || !ros::ok()) {
			server->setPreempted();
			return;
		}

		// Things that are lists in Python are STL vectors in C++.  Add something to the end with push_back.
		result.sequence.push_back(fibonacci(i));

		// Create an instance of the feedback data type, fill in the information, and publish it.
		rob599_basic::FibonacciFeedback feedback;
		feedback.progress = i;
		server->publishFeedback(feedback);
	}

	// If we get to here, then we're done.  Set the status to succeeded, and pass in the result instance, which will get sent over to the client.
	server->setSucceeded(result);
}


int main(int argc, char **argv) {
	// Initialize the node and allocate a node handle.
	ros::init(argc, argv, "action_server");
	ros::NodeHandle node;

	// Set up the action server.  It takes the NodeHandle, an action name, a bound callback, and the start state of the server (we're not going
	// to start it up at creation).  This is cleaner than doing a global variable to pass the server name.  boost::bind will cause the callback
	// to be called, with a pointer to server as the second argument.  This gives the callback access to the server instance.  There are other
	// ways to do this, but this one is clean and doesn't involve any nasty global variable scopes.
	actionlib::SimpleActionServer<rob599_basic::FibonacciAction> server(node, "fibonacci",
		boost::bind(&action_callback, _1, &server), false);
	server.start();
	ROS_INFO("Fibonacci action server started");

	// Give control over to ROS.
	ros::spin();

	return 0;
}